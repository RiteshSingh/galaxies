<html>
<head>
  <meta charset="UTF-8">
  <style>
    body { margin: 0; }
  </style>
  <script src="three/three.min.js"></script>
  <script src="three/TrackballControls.js"></script>
</head>

<body>
<script>

// Create an empty scene
var scene = new THREE.Scene();

// Create a basic perspective camera
var camera = new THREE.PerspectiveCamera( 75, window.innerWidth/window.innerHeight, 0.1, 1000 );
camera.position.x = 200;

// Create a renderer with Antialiasing
var renderer = new THREE.WebGLRenderer({antialias:true});

// Configure renderer clear color
renderer.setClearColor("#000000");

// Configure renderer size
renderer.setSize( window.innerWidth, window.innerHeight );

// Append Renderer to DOM
document.body.appendChild( renderer.domElement );

var colors = [];

//Add Milky Way with a special pink color
var dotGeometry = new THREE.Geometry();
dotGeometry.vertices.push(new THREE.Vector3( 0, 0, 0 ));
colors.push(new THREE.Color('#f9f'));

var rawFile = new XMLHttpRequest();
rawFile.open("GET", "galaxydata.txt", false);
rawFile.onreadystatechange = function ()
{
	if(rawFile.readyState === 4)
	{
		if(rawFile.status === 200 || rawFile.status == 0)
		{
			var allText = rawFile.responseText;
			var data = allText.split("\n");

			for (var i = 0; i < 4672; i++) {
				var parts = data[i].split("\t");

				var D = parts[0];
				var glon = parts[1]*3.1416/180;
				var glat = parts[2]*3.1416/180;

				var z = D*Math.sin(glat);
				var xy = D*Math.cos(glat);
				var x = xy*Math.cos(glon);
				var y = xy*Math.sin(glon);

				dotGeometry.vertices.push(new THREE.Vector3( x, y, z ));

				colors.push(new THREE.Color('#fff'));
			}
		}
	}
}
rawFile.send(null);

dotGeometry.colors = colors;

var size = 0.032;
var dotMaterial = new THREE.PointsMaterial({
	size: size,
	vertexColors: THREE.VertexColors,
});
var dots = new THREE.Points( dotGeometry, dotMaterial );
scene.add( dots );

var controls = new THREE.TrackballControls( camera, renderer.domElement );

// Render Loop
var render = function () {
  requestAnimationFrame( render );
  controls.update();
  // Render the scene
  renderer.render(scene, camera);
};
render();

window.addEventListener( 'resize', onWindowResize, false );
window.addEventListener( "mousemove", onDocumentMouseMove, false );

function onWindowResize() {

	camera.aspect = window.innerWidth / window.innerHeight;
	camera.updateProjectionMatrix();

	renderer.setSize( window.innerWidth, window.innerHeight );

}

var selectedObject = -1;

function onDocumentMouseMove( event ) {

	event.preventDefault();
	if ( selectedObject > 0 ) {

		dots.geometry.colors[selectedObject] = new THREE.Color('#fff');
		dots.geometry.colorsNeedUpdate = true;
		selectedObject = -1;

	} else if ( selectedObject == 0) {
	
		dots.geometry.colors[selectedObject] = new THREE.Color('#f9f');
		dots.geometry.colorsNeedUpdate = true;
		selectedObject = -1;
	
	}

	var intersects = getIntersects( event.layerX, event.layerY );
	if ( intersects.length > 0 ) {
		var idx = intersects[0].index;
		dots.geometry.colors[idx] = new THREE.Color('#69f');
		dots.geometry.colorsNeedUpdate = true;
		selectedObject = idx;
		console.log(idx);
	}
}

var raycaster = new THREE.Raycaster();
raycaster.params.Points.threshold = size*0.5;
var mouseVector = new THREE.Vector3();

function getIntersects( x, y ) {

	x = ( x / window.innerWidth ) * 2 - 1;
	y = - ( y / window.innerHeight ) * 2 + 1;

	mouseVector.set( x, y, 0.5 );
	raycaster.setFromCamera( mouseVector, camera );

	return raycaster.intersectObject( dots, true );

}

</script>
</body>
</html>
